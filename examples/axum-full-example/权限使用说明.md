# sa-token-rust 权限标识使用说明

## 核心问题：如何将权限标识（如 `user:list`）写入到 sa-token-rust 中？

本文档详细说明了如何在 `sa-token-rust` 中管理和使用权限标识。

---

## 一、权限标识的概念

### 1.1 什么是权限标识？

权限标识是一个字符串，用于表示用户可以执行的操作。例如：

```
user:list      - 查看用户列表
user:create    - 创建用户
user:update    - 更新用户
user:delete    - 删除用户
article:edit   - 编辑文章
system:config  - 系统配置
```

### 1.2 权限标识命名规范

推荐使用 `资源:操作` 的格式：

```rust
// ✅ 好的命名
"user:list"       // 清晰明确
"article:publish" // 符合规范
"system:config"   // 命名空间清晰

// ❌ 不好的命名
"listUser"        // 不够清晰
"all"             // 太宽泛
"permission1"     // 没有语义
```

### 1.3 通配符权限

支持使用 `*` 表示某个命名空间下的所有权限：

```rust
"admin:*"   // 拥有 admin 命名空间下的所有权限
"user:*"    // 拥有 user 命名空间下的所有权限
```

---

## 二、三种权限写入方式

### 方式一：启动时初始化（开发环境推荐）

#### 步骤 1：在 `main.rs` 中定义初始化函数

```rust
/// 初始化测试用户的权限和角色
async fn init_test_permissions(service: &PermissionService) {
    // 为管理员添加权限
    service.add_user_permissions(
        "admin",  // 用户 ID
        vec![
            "user:list".to_string(),      // 查看用户列表
            "user:create".to_string(),    // 创建用户
            "user:update".to_string(),    // 更新用户
            "user:delete".to_string(),    // 删除用户
            "system:config".to_string(),  // 系统配置
            "admin:*".to_string(),        // admin 命名空间所有权限
        ],
    ).await;
    
    // 为管理员添加角色
    service.add_user_roles(
        "admin",
        vec![
            "admin".to_string(),
            "user".to_string(),
        ],
    ).await;
    
    // 为普通用户添加权限
    service.add_user_permissions(
        "user",
        vec![
            "user:list".to_string(),
            "user:view".to_string(),
            "profile:edit".to_string(),
        ],
    ).await;
    
    service.add_user_roles(
        "user",
        vec!["user".to_string()],
    ).await;
}
```

#### 步骤 2：在 `main` 函数中调用

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // ... 创建存储和配置
    
    // 创建权限服务
    let permission_service = Arc::new(PermissionService::new());
    
    // ⚠️ 重要：初始化权限数据
    init_test_permissions(&permission_service).await;
    
    // ... 启动服务器
}
```

#### 优点
- ✅ 简单直接，适合开发和测试
- ✅ 不依赖外部存储
- ✅ 服务器启动即可使用

#### 缺点
- ❌ 每次重启数据丢失
- ❌ 不适合生产环境
- ❌ 无法动态修改

---

### 方式二：通过 API 动态管理（生产环境推荐）

#### 步骤 1：定义权限管理 API

```rust
/// 为用户添加权限
#[sa_check_role("admin")]
async fn add_permission(
    State(state): State<AppState>,
    Json(req): Json<AddPermissionRequest>,
) -> Result<Json<ApiResponse<String>>, ApiError> {
    let mut perms = state.permission_service
        .get_user_permissions(&req.user_id).await;
    
    // 添加新权限
    if !perms.contains(&req.permission) {
        perms.push(req.permission.clone());
        state.permission_service
            .add_user_permissions(&req.user_id, perms).await;
        
        Ok(Json(ApiResponse::success(format!(
            "成功为用户 {} 添加权限: {}",
            req.user_id, req.permission
        ))))
    } else {
        Ok(Json(ApiResponse::success(format!(
            "用户 {} 已拥有权限: {}",
            req.user_id, req.permission
        ))))
    }
}
```

#### 步骤 2：使用 API 添加权限

```bash
# 1. 管理员登录获取 token
TOKEN=$(curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"admin123"}' | jq -r '.data.token')

# 2. 为用户添加权限
curl -X POST http://localhost:3000/api/permission/add \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "user",
    "permission": "article:create"
  }'

# 3. 查看用户权限
curl -X GET http://localhost:3000/api/permission/list \
  -H "Authorization: Bearer $TOKEN"

# 4. 移除用户权限
curl -X POST http://localhost:3000/api/permission/remove \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "user",
    "permission": "article:create"
  }'
```

#### 优点
- ✅ 灵活动态，无需重启
- ✅ 适合生产环境
- ✅ 可以集成到管理后台

#### 缺点
- ❌ 需要实现管理 API
- ❌ 权限变更需要考虑并发安全

---

### 方式三：从数据库加载（生产环境最佳实践）

#### 步骤 1：设计数据库表结构

```sql
-- 用户权限表
CREATE TABLE user_permissions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id VARCHAR(64) NOT NULL,
    permission VARCHAR(128) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id)
);

-- 用户角色表
CREATE TABLE user_roles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id VARCHAR(64) NOT NULL,
    role VARCHAR(64) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id)
);
```

#### 步骤 2：实现数据库加载

```rust
use sqlx::{Pool, MySql};

impl PermissionService {
    /// 从数据库加载用户权限
    pub async fn load_from_database(
        &self,
        user_id: &str,
        pool: &Pool<MySql>
    ) -> Result<(), sqlx::Error> {
        // 1. 查询用户权限
        let permissions: Vec<String> = sqlx::query_scalar(
            "SELECT permission FROM user_permissions WHERE user_id = ?"
        )
        .bind(user_id)
        .fetch_all(pool)
        .await?;
        
        // 2. 查询用户角色
        let roles: Vec<String> = sqlx::query_scalar(
            "SELECT role FROM user_roles WHERE user_id = ?"
        )
        .bind(user_id)
        .fetch_all(pool)
        .await?;
        
        // 3. 加载到内存
        self.add_user_permissions(user_id, permissions).await;
        self.add_user_roles(user_id, roles).await;
        
        Ok(())
    }
    
    /// 保存用户权限到数据库
    pub async fn save_to_database(
        &self,
        user_id: &str,
        permissions: Vec<String>,
        pool: &Pool<MySql>
    ) -> Result<(), sqlx::Error> {
        // 1. 删除旧权限
        sqlx::query("DELETE FROM user_permissions WHERE user_id = ?")
            .bind(user_id)
            .execute(pool)
            .await?;
        
        // 2. 插入新权限
        for permission in permissions {
            sqlx::query(
                "INSERT INTO user_permissions (user_id, permission) VALUES (?, ?)"
            )
            .bind(user_id)
            .bind(&permission)
            .execute(pool)
            .await?;
        }
        
        Ok(())
    }
}
```

#### 步骤 3：在登录时加载权限

```rust
pub async fn login(
    State(state): State<AppState>,
    Json(req): Json<LoginRequest>,
) -> Result<Json<ApiResponse<LoginResponse>>, ApiError> {
    // 1. 验证用户名密码
    let user_id = authenticate(&req.username, &req.password)?;
    
    // 2. 从数据库加载权限（重要！）
    state.permission_service
        .load_from_database(&user_id, &state.db_pool)
        .await
        .map_err(|e| ApiError::InternalError(format!("加载权限失败: {}", e)))?;
    
    // 3. 生成 token
    let token = state.sa_token.manager
        .login(&user_id)
        .await
        .map_err(|e| ApiError::InternalError(format!("登录失败: {}", e)))?;
    
    // 4. 返回 token 和用户信息
    Ok(Json(ApiResponse::success(LoginResponse {
        token: token.to_string(),
        user_info: get_user_info(&user_id),
    })))
}
```

#### 优点
- ✅ 数据持久化，重启不丢失
- ✅ 适合生产环境
- ✅ 易于管理和审计
- ✅ 支持大规模用户

#### 缺点
- ❌ 需要数据库支持
- ❌ 实现复杂度较高
- ❌ 需要考虑缓存策略

---

## 三、权限使用示例

### 3.1 在路由处理函数中使用

#### 单个权限检查

```rust
/// 查看用户列表（需要 user:list 权限）
#[sa_check_permission("user:list")]
async fn list_users() -> Result<Json<Vec<User>>, ApiError> {
    // 业务逻辑
    Ok(Json(users))
}
```

#### 多个权限检查（AND）

```rust
/// 管理用户（需要同时拥有 user:read 和 user:write 权限）
#[sa_check_permissions_and("user:read", "user:write")]
async fn manage_user(req: Json<UserRequest>) -> Result<Json<String>, ApiError> {
    // 业务逻辑
    Ok(Json("操作成功".to_string()))
}
```

#### 多个权限检查（OR）

```rust
/// 查看用户（拥有任意一个权限即可）
#[sa_check_permissions_or("user:view", "admin:view")]
async fn view_user(req: Json<ViewRequest>) -> Result<Json<UserInfo>, ApiError> {
    // 业务逻辑
    Ok(Json(user_info))
}
```

### 3.2 角色检查

```rust
/// 管理员面板（需要 admin 角色）
#[sa_check_role("admin")]
async fn admin_panel() -> Result<Json<AdminData>, ApiError> {
    // 业务逻辑
    Ok(Json(admin_data))
}
```

### 3.3 忽略认证

```rust
/// 公开接口（不需要认证）
#[sa_ignore]
async fn public_api() -> &'static str {
    "公开接口"
}
```

---

## 四、完整示例

查看 `examples/axum-full-example` 目录下的完整示例：

```bash
# 1. 启动服务器
cd /Users/m1pro/rustproject/sa-token-rust/examples/axum-full-example
cargo run

# 2. 运行测试脚本
bash test.sh
```

---

## 五、最佳实践建议

### 5.1 权限粒度设计

- **粗粒度**：使用角色控制（如 `admin`、`user`、`guest`）
- **细粒度**：使用权限控制（如 `user:create`、`article:edit`）
- **推荐**：角色 + 权限组合使用

### 5.2 性能优化

1. **使用缓存**：将常用权限缓存到 Redis
2. **批量加载**：登录时一次性加载所有权限
3. **懒加载**：第一次使用时加载，后续从缓存读取

### 5.3 安全建议

1. **最小权限原则**：只给用户必要的权限
2. **定期审计**：记录权限变更日志
3. **权限过期**：支持权限过期时间
4. **动态刷新**：权限变更后及时通知客户端

### 5.4 数据库设计

```sql
-- 推荐的数据库表结构
CREATE TABLE permissions (
    id BIGINT PRIMARY KEY,
    user_id VARCHAR(64),
    permission VARCHAR(128),
    expires_at TIMESTAMP NULL,  -- 权限过期时间
    created_at TIMESTAMP,
    created_by VARCHAR(64),     -- 谁赋予的权限
    INDEX idx_user_id (user_id),
    INDEX idx_expires_at (expires_at)
);
```

---

## 六、常见问题

### Q1：权限变更后如何生效？

**答**：有两种方案：
1. **重新登录**：用户退出后重新登录，加载最新权限
2. **实时刷新**：使用 WebSocket 或轮询机制通知客户端刷新权限

### Q2：权限数据存储在哪里？

**答**：支持三种存储方式：
1. **内存存储**：使用 `MemoryStorage`（开发环境）
2. **Redis 存储**：使用 `RedisStorage`（生产环境缓存）
3. **数据库存储**：使用 `DatabaseStorage`（持久化存储）

### Q3：如何实现权限继承？

**答**：可以在权限服务中实现继承逻辑：

```rust
impl PermissionService {
    pub async fn has_permission_with_inheritance(
        &self,
        user_id: &str,
        permission: &str
    ) -> bool {
        // 1. 检查直接权限
        if self.has_permission(user_id, permission).await {
            return true;
        }
        
        // 2. 检查角色关联的权限
        let roles = self.get_user_roles(user_id).await;
        for role in roles {
            if self.role_has_permission(&role, permission).await {
                return true;
            }
        }
        
        false
    }
}
```

### Q4：如何支持权限通配符？

**答**：已内置支持，示例代码：

```rust
// 在 PermissionService 中已实现
pub async fn has_permission(&self, user_id: &str, permission: &str) -> bool {
    let permissions = self.get_user_permissions(user_id).await;
    
    // 精确匹配
    if permissions.contains(&permission.to_string()) {
        return true;
    }
    
    // 通配符匹配
    for perm in permissions {
        if perm.ends_with(":*") {
            let prefix = &perm[..perm.len() - 2];
            if permission.starts_with(prefix) {
                return true;
            }
        }
    }
    
    false
}
```

---

## 七、总结

权限标识的写入有三种方式：

1. **启动时初始化** - 适合开发测试
2. **API 动态管理** - 适合灵活配置
3. **数据库加载** - 适合生产环境

推荐的生产环境架构：

```
用户登录
  ↓
从数据库加载权限
  ↓
缓存到 Redis（可选）
  ↓
保存到内存（PermissionService）
  ↓
请求时检查权限（通过宏）
  ↓
执行业务逻辑
```

完整示例代码请查看：`examples/axum-full-example`

